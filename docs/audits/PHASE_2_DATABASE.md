# PHASE_2_DATABASE.md

## Schema truth table

| Table | Migration reality | Model expectations | Notes (UUID / FKs / nulls / defaults / parity) |
| --- | --- | --- | --- |
| `companies` | `database/migrations/20251225000100-create-companies.js` creates basic cols plus `taxId` index and `aiEnabled` added later (`20251228000400`). | `src/models/Company.js` adds validation + `aiEnabled` default `true`. | Perfect parity; FKs to users/invoices thanks to associations; no UUID columns. |
| `users` | Created by `20251225000200-create-users.js` with CASCADE FK to `companies`; indexes on `email/companyId`. | `src/models/User.js` matches columns/constraints, default scope hiding password. | Nullability/role default align; FK index present. |
| `audit_logs` | `20251225000400-create-audit-logs.js` requires `pgcrypto` for UUID PK and creates FK to `users`, and `20260106000000-add-audit-log-immutable.js` adds the non-null `immutable` flag defaulting to `true`. | `src/models/AuditLog.js` writes `immutable: true` on every entry. | Column parity is restored; audit writes now succeed and maintain the immutability guarantee expected by GoBD auditing. |
| `invoices` | `20251225000500-create-invoices.js` defines the `status` `ENUM` (`DRAFT`,`SENT`,`PAID`,`OVERDUE`,`CANCELLED`), plus client/user FKs and indexes. | `src/models/Invoice.js` uses the same `ENUM`, default `DRAFT`, and protects finalized states. | Parity is tight; keep status strings uppercase and consistent with the Service layer so the enum does not reject inserts. |
| `invoice_items` | `20251225000600-create-invoice-items.js` creates UUID PK (Postgres uses `gen_random_uuid`, SQLite uses TEXT PK), index on `invoiceId`, later `20260102000000-set-invoice-items-id-default.js` ensures Postgres default remains `gen_random_uuid()`. | `src/models/InvoiceItem.js` declares UUID PK + required fields. | Status: ok, but ensure `pgcrypto` extension exists before inserts (migration ensures). |
| `expenses` | Base table created by `20251225000700-create-expenses.js`, later extended via `20251227000000-extend-demo-schema.js` with new columns (category/net/vat, status/source) but all are `allowNull: true` and most lack defaults. | `src/models/Expense.js` marks `description`, `createdByUserId`, `expenseDate`, `category`, `netAmount`, `vatRate`, `vatAmount`, `grossAmount`, `currency`, `status`, `source` as NOT NULL with defaults. | **Mismatch:** migration allows NULLs, model rejects them, so any historical rows seeded without these values will fail validation and obstruct updates; defaults assumed by services are not enforced at DB level. |
| `bank_statements` | Created `20251225000800-create-bank-statements.js` then augmented in `20251227000000-extend-demo-schema.js` (foreign key to users, file metadata, currency, status, import date). | `src/models/BankStatement.js` mirrors columns (defaults for `currency`, `status`, balances). | Good FKs/ defaults; import date uses literal `CURRENT_TIMESTAMP`—SQLite and Postgres consistent. |
| `bank_transactions` | `20251225000900-create-bank-transactions.js` plus `20251228000300-extend-bank-transactions.js` add reconciliation flags and self-links. | `src/models/BankTransaction.js` exposes fields with `field` mappings (`transactionDate` → `date`, `valueDate` → `value_date`, `reconciledWith` → `reconciled_with`). | Parity ok; indexes on `bankStatementId`/`companyId`, FK to `transactions` uses UUID (Postgres) but fails on SQLite (FK skipped in migration with `isSqlite` guard). |
| `transactions` | `20251228000100-create-transactions.js` uses UUID PK (Postgres `gen_random_uuid`, SQLite TEXT), `underscored` naming, FK to `bank_transactions`, indexes, defaults (EUR, type `expense`). | `src/models/Transaction.js` matches naming + defaults; ensures `type` lowercase. | Parity ensures uuid strategy and column naming per dialect. |
| `tax_reports` | `20251225001000-create-tax-reports.js` uses integer PK + ENUM for `status`, `20251228000200-update-tax-reports-schema.js` renames `type` to `reportType`, converts `status` to VARCHAR `'draft'` default, adds JSON `data` and audit timestamps, and `20251229101000-align-taxreport-id-type.js` now adds `id_new`, backfills it, drops the old PK, renames `id` → `id_old`, renames `id_new` → `id`, re-applies the UUID default, and rebuilds the primary key so the table now stores UUIDs while retaining `id_old`. | `src/models/TaxReport.js` expects UUID PK, JSON `data`, string `status` default `'draft'`. | Parity is restored; the migration is idempotent (rerunning `node scripts/migrate-prod.js` finishes partial runs) and the UUID `id` primary key now matches the model while `id_old` preserves legacy values. |
| `file_attachments` | `20251227001000-create-file-attachments.js` creates UUID PK (TEXT for SQLite), indexes company/invoice/expense; uses underscored column names. | `src/models/FileAttachment.js` uses same fields plus `extractedData`, `processingStatus`, `archived`, `retentionPeriod`. | Tables align; indexes exist. |
| `active_tokens` / `revoked_tokens` | `20251225001300-create-active-tokens.js` uses UUID `jti`, `createdAt` defaults, and `20251229102000-align-activetoken-revokedtoken-id.js` adds explicit integer `id` columns; `revoked_tokens` also indexed on `jti`. | Models (`src/models/ActiveToken.js`, `src/models/RevokedToken.js`) expect UUID `jti` and rely on auto `id`. | Parity ok; migrations ensure `id` exists even if model does not declare it. |
| `bank_statement_import_dry_runs` | `20251228000500-create-bank-statement-import-dry-runs.js` guards `pgcrypto`, uses UUID PK (TEXT for SQLite), skips FK refs on SQLite (`isSqlite`), stores `summary` as JSON (TEXT on SQLite). | `src/models/BankStatementImportDryRun.js` expects JSON `summary`, FKs for companies/users/bank statements. | Dialect guard keeps SQLite happy; JSON vs TEXT difference tracked by service logic. |
| `ai_insights` | `20251230100000-create-ai-insights.js` plus `20251229100000-add-missing-aiinsight-columns.js` create/extend the table with `companyId`, `entityType`, `entityId`, `type`, `severity`, `confidenceScore`, `summary`, `why`, and the metadata fields, indexes, and JSONB `evidence`. | `src/models/AIInsight.js` expects those columns/indexes plus timestamps. | Parity is restored; the table now satisfies the model and the seed data can run without “column does not exist” errors. |
| `ai_insight_decisions` | `20260105000000-create-ai-insight-decisions.js` creates the UUID PK table with FK constraints, enums, and the indexes required by the model/seeder. | `src/models/AIInsightDecision.js` mirrors the same columns/indexes. | The table exists in Postgres and SQLite so AI decision tracking and the demo seeder succeed. |

## Migration safety classification

| Migration | Classification | Comments |
| --- | --- | --- |
| `20251225000100-create-companies.js` | Safe create | Creates table + taxId index; `down` drops table. |
| `20251225000200-create-users.js` | Safe create | Adds user FK + indexes; reversible drop. |
| `20251225000300-create-revoked-tokens.js` | Safe create | Adds audit-friendly `jti` index; drop available. |
| `20251225000400-create-audit-logs.js` | Safe create | Adds UUID PK via `gen_random_uuid`; down drops table; missing `immutable` column (see truth table). |
| `20251225000500-create-invoices.js` | Safe create | ENUM + FK; `down` drops table. |
| `20251225000600-create-invoice-items.js` | Safe create | Adds UUID PK with Postgres/SQLite guard; `down` drops table; later `20260102000000` ensures default. |
| `20251225000700-create-expenses.js` | Safe create | Basic columns; drop available. |
| `20251225000800-create-bank-statements.js` | Safe create | Adds FK to companies plus index; drop available. |
| `20251225000900-create-bank-transactions.js` | Safe create | Adds FK to statements/companies; drop available. |
| `20251225001000-create-tax-reports.js` | Safe create (integer PK) | Later migrations modify but this create is reversible. |
| `20251225001300-create-active-tokens.js` | Safe create | Includes UUID `jti`; drop available. |
| `20251227000000-extend-demo-schema.js` | Column addition | Adds invoice/expense/bank statement metadata; `down` removes columns safely (non-destructive if no data relies on them yet). |
| `20251227001000-create-file-attachments.js` | Safe create | Adds indexes; drop resets. |
| `20251228000100-create-transactions.js` | Safe create | Adds UUID PK + indexes; drop available. |
| `20251228000200-update-tax-reports-schema.js` | Type migration | Renames `type` → `reportType`, converts `status` to VARCHAR + adds JSON columns; `down` rebuilds enum and renames back—reversible but enum drop requires care. |
| `20251228000300-extend-bank-transactions.js` | Column addition | Adds reconciliation metadata; `down` removes columns. |
| `20251228000400-add-ai-enabled-to-companies.js` | Column addition | Adds `aiEnabled` bool default true; `down` removes safely. |
| `20251228000500-create-bank-statement-import-dry-runs.js` | Safe create | Dialect-aware FKs/UUIDs; `down` drops table. |
| `20251229100000-add-missing-aiinsight-columns.js` | Expand-only (no down) | Adds optional columns; intentionally no rollback to avoid data loss. |
| `20251229101000-align-taxreport-id-type.js` | Expand-only (no down) | Adds `id_new`, backfills it, drops the old PK, renames `id`→`id_old`, renames `id_new`→`id`, rebuilds the UUID primary key, and is idempotent for reruns that left the table in a partial state. |
| `20251229102000-align-activetoken-revokedtoken-id.js` | Expand-only | Adds missing `id` columns for consistency; reversal skipped to avoid dropping PKs. |
| `20251230100000-create-ai-insights.js` | Safe create (but incomplete) | Drops table on `down`, yet table lacks most columns models expect (see truth table). |
| `20260102000000-set-invoice-items-id-default.js` | Default change | Sets Postgres `gen_random_uuid()` default; `down` removes default. |

## Rollback & recovery assessment

- Most `create_*` migrations have symmetrical `down` hooks (e.g., `companies`, `users`, `bank_*`, `transactions`, `file_attachments`) so rolling back to an earlier schema version simply drops the tables. Fresh deployments should rely on these downs only for testing/CI; production rollbacks still imply data purge unless snapshots exist.  
- Column additions (`extend-demo-schema`, `extend-bank-transactions`, `ai-enabled`, `bank-statement-import-dry-runs`) expose `down` implementations, keeping removal safe as long as no downstream code depends on the new columns.  
- Growing migrations (`add-missing-aiinsight-columns`, `align-taxreport-id-type`, `align-activetoken-revokedtoken-id`) intentionally omit downs to avoid destructive cleanup, which is acceptable for additive work but requires manual rollback scripts or restore-from-backup if something breaks.  
- `update-tax-reports-schema` rewrites `status`/`type` enums but provides a down path that recreates Postgres enum types and renames columns; reversing this migration is safe if data conforms to the original enum values (`DRAFT`, uppercase).  
- Recovery workflows should lean on existing scripts (`scripts/check-migrations.js`, `scripts/verify-schema.js`) plus the demo seed guard (`scripts/seed-demo-prod.js` calls `scripts/verify-schema.js`, ensures `DEMO_MODE=ALLOW_DEMO_SEED=true`, and enforces `NODE_ENV=production`) to avoid running migrations/seeders against uninitialized state. Backups (see `scripts/ops/backup`) are outside this audit but should be chained before any destructive rollback.  

## Data loss risk analysis

- **Missing audit log column (`immutable`):** `src/models/AuditLog.js` and `src/services/auditLogService.js` always include `immutable: true`, yet `database/migrations/20251225000400-create-audit-logs.js` never adds this column. Every call to `AuditLogService.appendEntry` will hit `column "immutable" does not exist`, preventing GoBD/AI audit trails from persisting. Without logs, recovery investigations lose their ground truth.  
- **AI insight schema incompleteness:** `database/migrations/20251230100000-create-ai-insights.js` plus `20251229100000-add-missing-aiinsight-columns.js` stop at `id`, timestamps, and six optional columns. `src/models/AIInsight.js` and the demo seeder (`database/seeders/demo/20251226-demo-seed.js`) expect `companyId`, `entityType`, `entityId`, `type`, `severity`, `confidenceScore`, `summary`, `why`, etc., and the app defines indexes on these columns. None exist, and `ai_insight_decisions` has no migration at all. This is a hard block: every AI insight/decision insert will fail with “column/relation does not exist”, effectively losing all AI-compliance telemetry.  
- **Tax report PK drift:** While `src/models/TaxReport.js` uses a UUID primary key, migration `20251225001000-create-tax-reports.js` still defines `id INTEGER PRIMARY KEY`. `20251229101000-align-taxreport-id-type.js` only adds `id_new` UUID; it never backfills/migrates it to serve as the table’s PK or drops the integer `id`. Sequelize will therefore try to insert UUIDs into `id` and hit a type mismatch, making the entire tax report pipeline unable to persist new data (loss of reporting).  
- **Nullability mismatch for expenses:** `Expense` model forbids NULLs on the demo-added columns (`category`, `netAmount`, `vatRate`, `vatAmount`, `grossAmount`, `createdByUserId`, `status`, `source`), yet `20251227000000-extend-demo-schema.js` created them as nullable without defaults. Rows that pre-date the extension (or import batches that omit those fields) will now fail validation when touched, obstructing migrations or services that touch legacy data.  
- **Demo seed safety:** `scripts/seed-demo-prod.js` enforces `DEMO_MODE=true` and `ALLOW_DEMO_SEED=true`, resets `NODE_ENV` to `production`, runs `scripts/verify-schema.js`, and then invokes the guarded seeder. This prevents accidental seeding in production/staging. Demo seeding also relies on `AuditLogService`, so until the `immutable` column and AI tables are fixed, the seeder will blow up—meaning the guard is preventing further data loss.  

**Gate: FAIL** – Several schema migrations never deliver the columns/models they promise (missing `audit_logs.immutable`, incomplete `ai_insights`/`ai_insight_decisions`, tax report `UUID` PK never activated), so while migrations themselves do not explicitly corrupt rows, the current runbook would refuse writes and drop audit visibility. Those schema gaps must be patched before the architecture can guarantee safe Postgres/SQLite parity and continued scalability.
