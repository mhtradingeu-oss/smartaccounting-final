#!/usr/bin/env bash
set -euo pipefail

# =========================================
# SmartAccounting â€” PostgreSQL PITR Prepare
# =========================================
#
# This script prepares a PostgreSQL data directory for point-in-time recovery (PITR)
# using a base backup + archived WAL files.
#
# It DOES NOT start postgres. You must start postgres with PGDATA pointing to RESTORE_DIR.

# -------- Args --------
if [[ $# -lt 2 ]]; then
  echo "Usage: $0 <base-backup (tar.gz OR dir)> <target-timestamp UTC>" >&2
  echo "Example timestamp: 2026-01-06 12:00:00 UTC  OR  2026-01-06T12:00:00Z" >&2
  exit 1
fi

BASE_BACKUP="$1"
TARGET_TIME="$2"

# -------- Env --------
WAL_ARCHIVE_DIR="${WAL_ARCHIVE_DIR:-./backups/wal}"
RESTORE_DIR="${RESTORE_DIR:-./backups/pitr-restore}"
CONFIRM_PITR="${CONFIRM_PITR:-false}"

# -------- Helpers --------
fail() { echo "[PITR][ERROR] $1" >&2; exit 1; }
log()  { echo "[PITR][$(date -u +"%Y-%m-%d %H:%M:%S UTC")] $1"; }
require() { command -v "$1" >/dev/null 2>&1 || fail "Missing required command: $1"; }

# -------- Preconditions --------
require tar
require rm
require mkdir
require date

[[ -e "$BASE_BACKUP" ]] || fail "Base backup not found: $BASE_BACKUP"
[[ -d "$WAL_ARCHIVE_DIR" ]] || fail "WAL_ARCHIVE_DIR not found (directory required): $WAL_ARCHIVE_DIR"

if [[ "$CONFIRM_PITR" != "true" ]]; then
  fail "Refusing to prepare PITR without CONFIRM_PITR=true"
fi

# Basic timestamp sanity (accepts "... UTC" or "...Z")
if ! echo "$TARGET_TIME" | grep -Eq 'UTC$|Z$'; then
  log "WARNING: TARGET_TIME does not end with UTC or Z. You provided: $TARGET_TIME"
  log "Postgres expects recovery_target_time in a recognizable timestamp format."
fi

# -------- Prepare restore dir --------
log "Preparing restore directory: $RESTORE_DIR"
mkdir -p "$RESTORE_DIR"

# Danger barrier: refuse if RESTORE_DIR looks like a real PGDATA (has PG_VERSION) unless user cleaned it
if [[ -f "$RESTORE_DIR/PG_VERSION" ]]; then
  fail "RESTORE_DIR already contains PG_VERSION. Refusing to overwrite. Choose a new RESTORE_DIR or wipe it manually."
fi

# Clean only contents (keep dir)
rm -rf "$RESTORE_DIR"/*

# -------- Extract or copy base backup --------
if [[ -d "$BASE_BACKUP" ]]; then
  log "Base backup is a directory. Copying contents into RESTORE_DIR"
  require rsync
  rsync -a --delete "$BASE_BACKUP"/ "$RESTORE_DIR"/
else
  # assume tar.gz or tar
  log "Base backup is an archive. Extracting into RESTORE_DIR: $BASE_BACKUP"
  tar -xf "$BASE_BACKUP" -C "$RESTORE_DIR"
fi

# -------- Validate base backup looks like PGDATA --------
[[ -f "$RESTORE_DIR/PG_VERSION" ]] || fail "Base backup does not look like a valid PGDATA (PG_VERSION missing)."
[[ -d "$RESTORE_DIR/base" ]] || fail "Base backup invalid: missing 'base' directory."
[[ -d "$RESTORE_DIR/global" ]] || fail "Base backup invalid: missing 'global' directory."

log "Base backup looks like a valid PGDATA."

# -------- Write PITR config --------
log "Writing postgresql.auto.conf + recovery.signal"
AUTO_CONF="$RESTORE_DIR/postgresql.auto.conf"

cat > "$AUTO_CONF" <<EOF
# Generated by SmartAccounting PITR prepare script
restore_command = 'test -f "${WAL_ARCHIVE_DIR}/%f" && cp "${WAL_ARCHIVE_DIR}/%f" "%p"'
recovery_target_time = '${TARGET_TIME}'
recovery_target_action = 'promote'
EOF

touch "$RESTORE_DIR/recovery.signal"

log "PITR prepared successfully."
log "Next: start postgres with PGDATA=$RESTORE_DIR"
log "Example (docker): docker run ... -e PGDATA=/var/lib/postgresql/data ..."
log "Example (local): postgres -D \"$RESTORE_DIR\""
